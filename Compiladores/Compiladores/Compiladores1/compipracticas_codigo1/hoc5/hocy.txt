%{
#include   "hoc.h"
#define  code2(c1,c2)	    code(c1);   code(c2)
#define  code3(c1 ,c2,c3)   code(c1);   code(c2);  code(c3)

void yyerror (char *s);
int yylex ();
void warning(char *s, char *t);
void execerror(char *s, char *t);
void fpecatch(int e);
%}
%union   {
Symbol  *sym;   /* apuntador de la tabla de símbolos */ 
Inst    *inst;  /* instrucción de máquina */
}
%token  <sym>   NUMBER PRINT VAR BLTIN UNDEF WHILE IF ELSE 
%type   <inst>  stmt asgn expr stmtlist cond while if end

%right	'='
%left	OR
%left	AND
%left	GT GE LT LE EQ NE
%left	'+' '_'
%left	'*' '/'
%left	UNARYMINUS NOT
%right	
%%

list:     /* nada */ 
	| list '\n'
	| list asgn '\n'	{ puts("list asgn");code2(pop, STOP); return 1; }
	| list stmt '\n'	{ code(STOP); return 1; }
	| list expr '\n'	{ code2(print, STOP); return 1; }
	| list error '\n'	{ yyerrok; }
	;
asgn:     VAR '=' expr  { $$=$3; code3(varpush,(Inst)$1,assign); }
         ;
stmt:     expr   { code(pop); }
	| PRINT expr    { code(prexpr); $$ = $2;} 
	| while cond stmt end {
		($1)[1] = (Inst)$3;     /* cuerpo de la iteración */ 
		($1)[2] = (Inst)$4; }   /* terminar si la condición no se cumple */
	| if cond stmt end {    /* proposición if que no emplea else */ 
		($1)[1] = (Inst)$3;     /* parte then */ 
		($1)[3] = (Inst)$4; }   /* terminar si la condición no se cumple */ 
	| if cond stmt end ELSE stmt end {  /* proposición if con parte else */
		($1)[1]   =   (Inst)$3;	/*  parte then  */
		($1)[2]   =   (Inst)$6;	/* parte else   */
		($1)[3]   =   (Inst)$7;   } /*   terminar si la condición no se cumple  */
	|   '{'   stmtlist   '}' {   $$  =  $2;   }
        ;
cond:	'('   expr   ')'      {   code(STOP);  $$=  $2;   }
;
while:	WHILE   {   $$   =   code3(whilecode,STOP,STOP); }
	;
if:IF   { $$=code(ifcode); code3(STOP, STOP, STOP); }
	;
end:      /* nada */{ code(STOP); $$ = progp; }
	;
stmtlist: /* nada */	{ $$ = progp; }
	| stmtlist '\n' 
	| stmtlist stmt
	;
expr:    NUMBER { $$ = code2(constpush, (Inst)$1); }
	| VAR	{  $$ = code3(varpush, (Inst)$1, eval);}
	| asgn
	|	BLTIN '(' expr ')'
	{ $$ = $3; code2(bltin,(Inst)$1->u.ptr); }
	|	'(' expr ')'  { $$ = $2; }
	|expr '+' expr { code(add); }
	|expr '-' expr { code(sub); }
	|expr '*' expr { code(mul); }
	|expr '/' expr { code(div); }
	|expr '^' expr { code (power); }
	|'-' expr %prec UNARYMINUS  { $$ = $2; code(negate); }
	|expr GT expr  { code(gt); }
	|expr GE expr  { code(ge); }
	|expr LT expr  { code(lt); }
	|expr LE expr  { code(le); }
	|expr EQ expr  { code (eq); }
	|expr NE expr  { code(ne); }
	|expr AND expr { code(and); }
	|expr OR expr  { code(or); }
	|NOT expr      { $$ = $2; code(not); }
	;
%%
#include <stdio.h>
#include <ctype.h>
#include <signal.h>
#include <setjmp.h>

jmp_buf begin;

char *progname;
int lineno = 1;

main(int argc, char **argv)       /* hoc5 */ 
{
/*int  fpecatch();*/
progname  =  argv[0];
init( );
setjmp(begin);
signal(SIGFPE, fpecatch);
for (initcode(); yyparse(); initcode() )
execute(prog); 
return 0; 
}

yylex()
{
int c;
while  ((c=getchar()) ==  ' ' ||  c ==   '\t')
          ;
if (c == EOF)
	return 0; 
if (c == '.' || isdigit(c)) {   /* número */
	double d;
	ungetc(c, stdin); 
	scanf("%lf", &d);
	yylval.sym = install("", NUMBER, d);
	return NUMBER; 
}
if (isalpha(c)) { 
	Symbol *s;
	char sbuf[100], *p = sbuf; 
	do {
		if (p >= sbuf + sizeof(sbuf) - 1) { 
			*p = '\0'; 
			execerror("name too long", sbuf);
		}
	*p++ = c;
	} while ((c=getc(stdin)) != EOF && isalnum(c)); 
	ungetc(c, stdin); 
	*p = '\0'; 
	if ((s=lookup(sbuf)) == 0)
       		s=install(sbuf, UNDEF, 0.0); 
	yylval.sym = s;
	return s->type == UNDEF ? VAR : s->type;
}
	switch (c) {
	case '>':                return follow('=', GE, GT);
	case '<':                return follow('=', LE, LT);
	case '=':                return follow('=', EQ, '=');
	case '!':                return follow('=', NE, NOT);
	case '|':                return follow('|', OR, '|');
	case '&':                return follow('&', AND, '&');
	case '\n':              lineno++; return '\n';
	default:                  return c; 
        }
}

follow(expect,   ifyes,   ifno)  /*   buscar  >=, etc.   */ 
{
int c  = getchar();
if  (c  ==  expect)
return ifyes; 
ungetc(c,   stdin); 
return  ifno;
}

void yyerror(char *s)      /* comunicar errores de tiempo de compilación */
{
warning(s, (char *)0); 
} 

void execerror(char *s, char *t)
{
	warning(s, t);
	longjmp(begin, 0);
}

void fpecatch(int e)      /* detectar errores por punto flotante */ 
{
execerror("floating point exception", (char *) 0); 
}	

void warning(char *s, char *t)
{
	fprintf (stderr, "%s: %s", progname, s);
	if(t)
		fprintf (stderr, " %s", t);
	fprintf (stderr, "cerca de la linea %d\n", lineno);
}



	
